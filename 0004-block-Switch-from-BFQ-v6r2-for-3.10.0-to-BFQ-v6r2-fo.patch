diff -aur linux-3.10/block/bfq-iosched.c linux-3.10.new/block/bfq-iosched.c
--- linux-3.10/block/bfq-iosched.c	2014-01-30 10:34:28.892392857 +0000
+++ linux-3.10.new/block/bfq-iosched.c	2014-01-30 10:42:34.617366593 +0000
@@ -3121,15 +3121,23 @@
 	kfree(bfqd);
 }
 
-static int bfq_init_queue(struct request_queue *q)
+static int bfq_init_queue(struct request_queue *q, struct elevator_type *e)
 {
 	struct bfq_group *bfqg;
 	struct bfq_data *bfqd;
+	struct elevator_queue *eq;
 
-	bfqd = kzalloc_node(sizeof(*bfqd), GFP_KERNEL, q->node);
-	if (bfqd == NULL)
+	eq = elevator_alloc(q, e);
+	if (eq == NULL)
 		return -ENOMEM;
 
+	bfqd = kmalloc_node(sizeof(*bfqd), GFP_KERNEL | __GFP_ZERO, q->node);
+	if (bfqd == NULL) {
+		kobject_put(&eq->kobj);
+		return -ENOMEM;
+	}
+	eq->elevator_data = bfqd;
+
 	/*
 	 * Our fallback bfqq if bfq_find_alloc_queue() runs into OOM issues.
 	 * Grab a permanent reference to it, so that the normal code flow
@@ -3139,11 +3147,15 @@
 	atomic_inc(&bfqd->oom_bfqq.ref);
 
 	bfqd->queue = q;
-	q->elevator->elevator_data = bfqd;
+
+	spin_lock_irq(q->queue_lock);
+	q->elevator = eq;
+	spin_unlock_irq(q->queue_lock);
 
 	bfqg = bfq_alloc_root_group(bfqd, q->node);
 	if (bfqg == NULL) {
 		kfree(bfqd);
+		kobject_put(&eq->kobj);
 		return -ENOMEM;
 	}
